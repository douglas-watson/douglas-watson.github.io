<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming notes</title>
    <link>http://douglas-watson.github.io/</link>
    <description>Recent content on Programming notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Dec 2015 16:15:13 +0100</lastBuildDate>
    <atom:link href="http://douglas-watson.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The MIT License (MIT)</title>
      <link>http://douglas-watson.github.io/license/</link>
      <pubDate>Sun, 27 Dec 2015 16:15:13 +0100</pubDate>
      
      <guid>http://douglas-watson.github.io/license/</guid>
      <description>&lt;p&gt;Copyright © 2015-2016 Douglas C. Watson&lt;/p&gt;

&lt;p&gt;Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the “Software”), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:&lt;/p&gt;

&lt;p&gt;The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.&lt;/p&gt;

&lt;p&gt;THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swiss parliament transcriptions</title>
      <link>http://douglas-watson.github.io/projects/parliament/</link>
      <pubDate>Sun, 27 Dec 2015 16:15:13 +0100</pubDate>
      
      <guid>http://douglas-watson.github.io/projects/parliament/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/douglas-watson/parl-scraping&#34;&gt;https://github.com/douglas-watson/parl-scraping&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With a team of fellow hackers during the &lt;a href=&#34;http://make.opendata.ch/wiki/event:2015-09&#34;&gt;OpenData Election Hackdays&lt;/a&gt;, and in partnership with the newspaper Le Temps, we compiled a full-text-searchable index of the transcriptions of all parliamentary interventions of the Swiss government, since 1990. The result can be browsed online at &lt;a href=&#34;http://parlement.letemps.ch&#34;&gt;parlement.letemps.ch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/projects/raclette_search.png&#34; alt=&#34;Search results&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The core of the project is a web scraper, which retrieved all the transcriptions from the official Swiss website, and combined the transcription with biographical information about the speakers (moslty party affiliations and canton of origin). The product is a large database of machine-readable transcriptions which can easily be re-used by researchers in different tool. We produced the data in two formats: CSV and JSON. The CSV data can be imported in R and Tableau, as well as other natural language processing and graphing tools. The JSON data can be imported into ElasticSearch. We additionally set up a Kibana interface for quick searches and analytics, hosted at &lt;a href=&#34;http://parlement.letemps.ch&#34;&gt;parlement.letemps.ch&lt;/a&gt;. Check out the &lt;a href=&#34;https://github.com/douglas-watson/parl-scraping&#34;&gt;github page&lt;/a&gt; for instructions on using Kibana, on settings up your own ElasticSearch server (including docker files), and rebuilding the index with a web scraper.&lt;/p&gt;

&lt;p&gt;More information about the project on the hackathon wiki: &lt;a href=&#34;http://make.opendata.ch/wiki/project:chparlscraping&#34;&gt;http://make.opendata.ch/wiki/project:chparlscraping&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/projects/raclette_search.png&#34; alt=&#34;Visualization on Kibana&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build an internet-of-things dashboard with Google Sheets and RStudio Shiny: Tutorial part 3/3.</title>
      <link>http://douglas-watson.github.io/post/gdocs_3_shiny/</link>
      <pubDate>Sun, 27 Dec 2015 13:21:42 +0100</pubDate>
      
      <guid>http://douglas-watson.github.io/post/gdocs_3_shiny/</guid>
      <description>

&lt;p&gt;This is the third and final part of the Shiny + Google Docs dashboard tutorial, where I explain how to build a live web dashboard for connected &amp;ldquo;Internet of Things&amp;rdquo; sensors, using Google Sheets as a data server. &lt;a href=&#34;http://douglas-watson.github.io/post/gdocs_1_gdocs/&#34;&gt;Part one&lt;/a&gt; covered setting up a Google Sheet to store and serve data through HTTP requests; &lt;a href=&#34;http://douglas-watson.github.io/post/gdocs_2_r/&#34;&gt;part two&lt;/a&gt; covered reading, filtering, and plotting that data in R. In this part, we&amp;rsquo;ll create the actual dashboard and host it online.&lt;/p&gt;

&lt;p&gt;Shiny adds a web server and an interactive web front end to R code and graphics. We&amp;rsquo;ll use it to make a web-based dashboard, in other words a collection of plots that display the latest sensor data with some widgets to modify the plots. In this section, we&amp;rsquo;ll first build a simple page that shows a time series and boxplot with the latest data from Google Sheets. We&amp;rsquo;ll then add a date selection widget that narrows down the time period to be displayed.&lt;/p&gt;

&lt;p&gt;The finished shiny app is on Github: &lt;a href=&#34;https://github.com/douglas-watson/shiny-gdocs&#34;&gt;https://github.com/douglas-watson/shiny-gdocs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;setting-up-shiny:bffe4c52645e4aa5f295033954d0e261&#34;&gt;Setting up Shiny&lt;/h2&gt;

&lt;p&gt;I recommend you follow the official tutorial (&lt;a href=&#34;http://shiny.rstudio.com/tutorial/&#34;&gt;http://shiny.rstudio.com/tutorial/&lt;/a&gt;) for the latest installation instructions. If you have time, follow the entire tutorial for a complete overview of the Shiny way of thinking.&lt;/p&gt;

&lt;h2 id=&#34;our-first-dashboard-no-interactivity:bffe4c52645e4aa5f295033954d0e261&#34;&gt;Our first dashboard: no interactivity&lt;/h2&gt;

&lt;p&gt;Our first dashboard will simply display two plots, which show the latest data fetched from Google Sheets. Shiny applications consist of two files: &lt;code&gt;ui.R&lt;/code&gt; and &lt;code&gt;server.R&lt;/code&gt;. The UI file defines the layout of the dashboard: what visualizations are shown, and where they are placed on the page. In this file, we only name the visualizations and define their type (table, plot, &amp;hellip;); the actual contents of the visualizations will be defined in &lt;code&gt;server.R&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The code example below defines a container: &lt;code&gt;shinyUI(fluidPage(....))&lt;/code&gt;. Inside the container is a vertical layout box, which lays out its children in a vertical stack. Inside the layout, we placed three items: a title bar and two plot items.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ui.R

shinyUI(fluidPage(
  verticalLayout(
    titlePanel(&amp;quot;Sensor data dashboard&amp;quot;),
    plotOutput(&amp;quot;timeseries&amp;quot;),
    plotOutput(&amp;quot;boxplot&amp;quot;)
  )  
))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is to render graphics that can be displayed in the plotOutputs; we do this in &lt;code&gt;server.R&lt;/code&gt;. The server code is broken down into three parts, code that is run:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;when the server is started;&lt;/li&gt;
&lt;li&gt;each time a page is accessed;&lt;/li&gt;
&lt;li&gt;each time an interactive widget is changed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In our case, when the server is started we only want to import the helper code (data loading and plotting functions), but not execute any of it. Each time a page is loaded, we want to fetch new data and draw the plots. We have no widgets yet, and therefore no code in the third category.&lt;/p&gt;

&lt;p&gt;The first draft of server code, below, does just that: code outside of the &lt;code&gt;shinyServer(...)&lt;/code&gt; block is executed just once, code inside it is executed every time the page is accessed. This last block fetches the raw data, creates a time series plot and places it into the the &lt;code&gt;plotOuput&lt;/code&gt; named &amp;ldquo;timeseries&amp;rdquo; which we defined in &lt;code&gt;ui.R&lt;/code&gt;, then renders a boxplot into the &amp;ldquo;boxplot&amp;rdquo; &lt;code&gt;plotOutput&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# server.R

source(&amp;quot;helpers.R&amp;quot;)

shinyServer(function(input, output) {

  # Load data when app is visited
  data &amp;lt;- getRaw()

  # Populate plots
  output$timeseries &amp;lt;- renderPlot({
    timeseriesPlot(data)
  })

  output$boxplot &amp;lt;- renderPlot({
    boxPlot(data)
  })

})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create the &lt;code&gt;ui.R&lt;/code&gt; and &lt;code&gt;server.R&lt;/code&gt; files in the same directory as &lt;code&gt;helpers.R&lt;/code&gt;, which you created at the end of the previous section. RStudio automatically detects that the files are Shiny application and adds a &amp;ldquo;Run App&amp;rdquo; button the toolbar above the editor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/33_run_btn.png&#34; alt=&#34;RStudio adds a run button to Shiny applications&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Use that button to preview the application. It should pop up a window similar to the one below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/31_basicui.png&#34; alt=&#34;Our first dashboard, with two static graphs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note that none of our code detects changes on the google document; you still need to refresh the page to get the latest data.&lt;/p&gt;

&lt;h2 id=&#34;add-a-grid-layout-and-filter-by-date:bffe4c52645e4aa5f295033954d0e261&#34;&gt;Add a grid layout and filter by date&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s now add some date selection widgets that restrict the displayed date range. We&amp;rsquo;ll first extend the layout from a simple vertical stack to a &lt;em&gt;fluid grid&lt;/em&gt;. On sufficiently wide displays, this layout shows up as a grid. On narrower displays, it reverts to a vertical stack, to avoid lateral scrolling. Grids are specified as &lt;code&gt;fluidRow&lt;/code&gt; elements which contain &lt;code&gt;column&lt;/code&gt; elements. Each column is assigned a width (in units of &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt; of the screen width) and can contain another widget (an input, a plot, or another grid). The new &lt;code&gt;ui.R&lt;/code&gt; file below now shows a layout with nested rows and columns.&lt;/p&gt;

&lt;p&gt;Our second modification is to add input widgets. Inputs allow users to interact with the visualization by entering text, number, dates, selecting from radio boxes&amp;hellip;You can browse the full gallery &lt;a href=&#34;http://shiny.rstudio.com/gallery/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use two kinds of inputs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dateRangeInput&lt;/code&gt;: a drop-down calendar to chose a start and end date.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numericInput&lt;/code&gt;: a box which accepts only numbers, and shows an up- and down-arrow to change the numbers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We use the dateRangeInput to specify the date range of data to plot, and four numeric inputs to specify the hours and minutes of the start day, and the hours and minutes of the end day.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ui.R

shinyUI(fluidPage(
  verticalLayout(
    titlePanel(&amp;quot;Sensor data dashboard&amp;quot;),
    fluidRow(
      column(3,
             dateRangeInput(&amp;quot;dates&amp;quot;, &amp;quot;Date Range&amp;quot;, start=&amp;quot;2015-11-20&amp;quot;),
             fluidRow(
               column(4, h3(&amp;quot;From:&amp;quot;)),
               column(4, numericInput(&amp;quot;min.hours&amp;quot;, &amp;quot;hours:&amp;quot;, value=0)),
               column(4, numericInput(&amp;quot;min.minutes&amp;quot;, &amp;quot;minutes:&amp;quot;, value=0))
             ),
             fluidRow(
               column(4, h3(&amp;quot;To:&amp;quot;)),
               column(4, numericInput(&amp;quot;max.hours&amp;quot;, &amp;quot;hours:&amp;quot;, value=23)),
               column(4, numericInput(&amp;quot;max.minutes&amp;quot;, &amp;quot;minutes:&amp;quot;, value=59))
             )
      ),
      column(9, plotOutput(&amp;quot;timeseries&amp;quot;))
    ),
    fluidRow(
      column(3),
      column(9, plotOutput(&amp;quot;boxplot&amp;quot;))
    )
  )
))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The server-side code can access the values of the input widgets through the &lt;code&gt;input&lt;/code&gt; argument of &lt;code&gt;ShinyServers&lt;/code&gt;&amp;rsquo;s callback. When one of the inputs is changed on the UI, Shiny automatically re-executes any of the server&amp;rsquo;s &lt;code&gt;renderPlot&lt;/code&gt; or &lt;code&gt;reactive&lt;/code&gt; code blocks that access that value. The &lt;code&gt;reactive&lt;/code&gt; blocks are useful to transform data according to input values; we will thus use one to apply the date range filter.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;reactive&lt;/code&gt; block in the new code example below converts our inputs to two POSIXct date objects, then uses them as lower and upper bounds to filter the data frame. We assign the reactive code block to &lt;code&gt;data.filt&lt;/code&gt;, and modify the &lt;code&gt;renderPlot&lt;/code&gt; calls to plot &lt;code&gt;data.filt()&lt;/code&gt; instead of the original &lt;code&gt;data&lt;/code&gt;. Note the syntax: &lt;code&gt;data.filt()&lt;/code&gt; returns the value of the code block passed to &lt;code&gt;reactive&lt;/code&gt;. As explained above, each time one of the inputs used inside the &lt;code&gt;reactive&lt;/code&gt; block is updated, any other code block which calls &lt;code&gt;data.filt()&lt;/code&gt; is also updated. In the example below, both &lt;code&gt;renderPlot&lt;/code&gt; blocks are re-executed on update.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; make sure to include the parenthesis each time you call &lt;code&gt;data.filt()&lt;/code&gt;!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# server.R

source(&amp;quot;helpers.R&amp;quot;)

shinyServer(function(input, output) {

  # Load data when app is visited
  data &amp;lt;- getRaw()

  # Filter by device ID / time range when options are updated
  data.filt &amp;lt;- reactive({
    mindate &amp;lt;- as.POSIXct.Date(input$dates[1]) + (input$min.hours * 60 + input$min.minutes) * 60
    maxdate &amp;lt;- as.POSIXct.Date(input$dates[2]) + (input$max.hours * 60 + input$max.minutes) * 60

    subset(data, date &amp;gt; mindate &amp;amp; date &amp;lt; maxdate)
  })

  # Populate plots
  output$timeseries &amp;lt;- renderPlot({
    timeseriesPlot(data.filt())
  })

  output$boxplot &amp;lt;- renderPlot({
    boxPlot(data.filt())
  })

})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the application again. The new result should resemble my example below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/32_fullui.png&#34; alt=&#34;Our improved dashboard, now with date range selection&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;publish-to-shinyapps-io:bffe4c52645e4aa5f295033954d0e261&#34;&gt;Publish to Shinyapps.io&lt;/h2&gt;

&lt;p&gt;ShinyApps.io provides a hosting service for Shiny apps, and is another product by the makers of RStudio. Their developers integrated the service into RStudio: simply click &amp;ldquo;Publish&amp;rdquo; in the upper right corner of your Shiny app preview, and follow the instructions! Create a free account and upload your dashboard.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/35_publish_btn.png&#34; alt=&#34;Publish your dashboard to ShinyApps.io from RStudio&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/34_publish.png&#34; alt=&#34;Publish your dashboard to ShinyApps.io from RStudio&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Once the app is published, you will notice a problem remains: nothing shows up on your dashboard. If you check the server logs, you&amp;rsquo;ll notice that HTTPS requests from R to Google Sheets failed. The final section of our tutorial, below, will explain how to work around that.&lt;/p&gt;

&lt;h2 id=&#34;using-an-https-to-http-proxy:bffe4c52645e4aa5f295033954d0e261&#34;&gt;Using an https to http proxy&lt;/h2&gt;

&lt;p&gt;Sadly, ShinyApps (at the time of writing) doesn&amp;rsquo;t support https URLs, and thus blocks the request to Google Sheets. To work around this, we need to route the requests through an external server (a proxy) which is accessible through HTTP, can fetch the target HTTPS page, and return it back to R&amp;rsquo;s &lt;code&gt;read.csv&lt;/code&gt; request through HTTP. Doing this goes against the security benefits of HTTPS, but since we are making a public dashboard from data publicly available on a Google Sheet, and mostly for demonstration only, I&amp;rsquo;m not concerned about it.&lt;/p&gt;

&lt;p&gt;To save you the work, I set up a HTTPS-to-HTTP proxy server. In the &lt;code&gt;server.R&lt;/code&gt; code, add &lt;code&gt;shinyproxy.appspot.com/&lt;/code&gt; before &lt;code&gt;script.google.com/&lt;/code&gt;. In my case, the URL becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# fragment of helpers.R

data &amp;lt;- read.csv(
  url(&amp;quot;https://shinyproxy.appspot.com/script.google.com/macros/s/AKfycbxOw-Tl_r0jDV4wcnixdYdUjcNipSzgufiezRKr28Q5OAN50cIP/exec?sheet=Raw&amp;quot;),
  strip.white = TRUE
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Re-publish your dashboard, and you are done!&lt;/p&gt;

&lt;h3 id=&#34;more-on-the-proxy:bffe4c52645e4aa5f295033954d0e261&#34;&gt;More on the proxy&lt;/h3&gt;

&lt;p&gt;The HTTPS proxy is a simple piece of Go code hosted on App Engine. I put the code on github, here: &lt;a href=&#34;https://github.com/douglas-watson/httpsproxy&#34;&gt;https://github.com/douglas-watson/httpsproxy&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build an internet-of-things dashboard with Google Sheets and RStudio Shiny: Tutorial part 2/3.</title>
      <link>http://douglas-watson.github.io/post/gdocs_2_r/</link>
      <pubDate>Sun, 27 Dec 2015 13:21:38 +0100</pubDate>
      
      <guid>http://douglas-watson.github.io/post/gdocs_2_r/</guid>
      <description>

&lt;p&gt;This is the second installment of the Shiny + GDocs dashboard tutorial, where we learn how to use a Google Sheet spreadsheet to store data from connected &amp;ldquo;Internet of Things&amp;rdquo; data and use Shiny to create a web page to show the data. The &lt;a href=&#34;http://douglas-watson.github.io/post/gdocs_1_gdocs/&#34;&gt;first part&lt;/a&gt; showed you how to set up a Google Sheet to serve as a data server that accepts POST and GET HTTP requests, as well as how to use pivot tables and filters on the sheets directly. In this section, I&amp;rsquo;ll walk you through the specific aspects of R that we will wrap in Shiny code. We&amp;rsquo;ll cover: how to download CSV data from the web, handling date fields, and making various plots with ggplot2. I assume if you are reading tutorial that you already are using R and found the tutorial through a desire to connect to Google Sheets data. If not, I hope this overview will motivate you to learn more R!&lt;/p&gt;

&lt;p&gt;If you want to skip to using Shiny, head over to &lt;a href=&#34;http://douglas-watson.github.io/post/gdocs_3_shiny&#34;&gt;part 3&lt;/a&gt;. The finished code files are available on Github: &lt;a href=&#34;https://github.com/douglas-watson/shiny-gdocs&#34;&gt;https://github.com/douglas-watson/shiny-gdocs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;recommended-setup:94191fbd145b96fca71414b523ebad09&#34;&gt;Recommended setup&lt;/h2&gt;

&lt;p&gt;If you are an experienced R user, you already know what development environment you prefer. Use that one. If not, I recommend RStudio, available for Linux, Mac, and Windows. It has a decent editor (with Vim mode!) and integrates with Shiny. Head over to &lt;a href=&#34;https://www.rstudio.com/products/rstudio/#Desktop&#34;&gt;https://www.rstudio.com/products/rstudio/#Desktop&lt;/a&gt; to download it.&lt;/p&gt;

&lt;p&gt;You will also need R and the ggplot2. Install R from your package manager on Linux, or download it from here on other platforms: &lt;a href=&#34;https://www.r-project.org/&#34;&gt;https://www.r-project.org/&lt;/a&gt;. Once R and RStudio are installed, open RStudio, and install ggplot2 from the R console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install.packages(&#39;ggplot2&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;import-a-csv-file-from-a-web-url:94191fbd145b96fca71414b523ebad09&#34;&gt;Import a CSV file from a web URL&lt;/h2&gt;

&lt;p&gt;Fetching CSV data from the web is trivial: just feed &lt;code&gt;read.csv&lt;/code&gt; a &lt;code&gt;url&lt;/code&gt; parameter, it automatically downloads the data and makes a data frame with the correct header names. Create a &amp;ldquo;helpers.R&amp;rdquo; file, and write the following code in it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getRaw &amp;lt;- function () {
  data &amp;lt;- read.csv(
    url(&amp;quot;https://script.google.com/macros/s/AKfycbxOw-Tl_r0jDV4wcnixdYdUjcNipSzgufiezRKr28Q5OAN50cIP/exec?sheet=Raw&amp;quot;),
    strip.white = TRUE
  )
  data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We call the file helpers.R, as it will be used later by the Shiny app. The &lt;code&gt;getRaw&lt;/code&gt; function returns a data frame with five variables, named identically to the spreadsheet&amp;rsquo;s headers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; data &amp;lt;- getRaw()
&amp;gt; summary(data)
   timestamp                                              date         origin           variable       value      
 Min.   :1.448e+09   Mon Nov 23 2015 22:44:45 GMT+0100 (CET):  4   bedroom:120   humidity   :120   Min.   :23.00  
 1st Qu.:1.448e+09   Mon Nov 23 2015 23:44:45 GMT+0100 (CET):  4   kitchen:120   temperature:120   1st Qu.:23.88  
 Median :1.448e+09   Thu Nov 26 2015 00:44:45 GMT+0100 (CET):  4                                   Median :32.55  
 Mean   :1.448e+09   Thu Nov 26 2015 01:44:45 GMT+0100 (CET):  4                                   Mean   :34.34  
 3rd Qu.:1.448e+09   Thu Nov 26 2015 02:44:45 GMT+0100 (CET):  4                                   3rd Qu.:44.45  
 Max.   :1.449e+09   Thu Nov 26 2015 03:44:45 GMT+0100 (CET):  4                                   Max.   :49.90  
                     (Other)                                :216                                                  
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;convert-date-time-column:94191fbd145b96fca71414b523ebad09&#34;&gt;Convert date-time column&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s now convert the date-time data to a proper R date object. The easiest way is to transform the UNIX timestamp column into a &lt;code&gt;POSIXct&lt;/code&gt; object, and replace the &amp;ldquo;date&amp;rdquo; column. Since we generated UTC dates, we set the time zone to &amp;ldquo;GMT&amp;rdquo;. Complete the getRaw function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getRaw &amp;lt;- function () {
  data &amp;lt;- read.csv(
    url(&amp;quot;https://script.google.com/macros/s/AKfycbxOw-Tl_r0jDV4wcnixdYdUjcNipSzgufiezRKr28Q5OAN50cIP/exec?sheet=Raw&amp;quot;),
    strip.white = TRUE
  )
  data$date = as.POSIXct(data$timestamp, tz=&amp;quot;GMT&amp;quot;, origin=&amp;quot;1970-01-01&amp;quot;)
  data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;re now ready to rock!&lt;/p&gt;

&lt;h2 id=&#34;play-with-ggplot2:94191fbd145b96fca71414b523ebad09&#34;&gt;Play with ggplot2&lt;/h2&gt;

&lt;p&gt;The ggplot2 library provides the brilliant &lt;code&gt;qplot&lt;/code&gt; function. A single line of code can produce a huge variety of plots, which makes R my favourite tool to  play with data.&lt;/p&gt;

&lt;p&gt;To start off, let&amp;rsquo;s plot all the values we recorded as a function of time. If you haven&amp;rsquo;t already, import ggplot2 and helpers.R, and load the CSV data in a data frame.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import(ggplot2)
source(&amp;quot;helpers.R&amp;quot;)
data &amp;lt;- getRaw()
qplot(date, value, data = data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/21_all.png&#34; alt=&#34;All points on a single plot, a good start, but not very clear.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can clarify the plot a little by colouring points according to sensor location:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qplot(date, value, data = data, colour = origin)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/22_colours.png&#34; alt=&#34;Colouring the points as a function of sensor locations clarifies the plot a bit.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We still can&amp;rsquo;t distinguish temperature from humidity. Let&amp;rsquo;s separate those variables into different panels using &amp;ldquo;facets&amp;rdquo;. We&amp;rsquo;ll add the &amp;ldquo;free_y&amp;rdquo; option to allow each y to scale independently:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qplot(date, value, data = data, colour = origin) + facet_grid(variable ~ ., scales = &amp;quot;free_y&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/23_facets.png&#34; alt=&#34;Faceted by variable.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Since there is a lot of noise, joining the points with a line makes the plot easier to read:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qplot(date, value, data = data, colour = origin, geom = &amp;quot;line&amp;quot;) + facet_grid(variable ~ ., scales = &amp;quot;free_y&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/24_timeseries.png&#34; alt=&#34;Points replaced by lines&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you add a sensor in a new room, a new line colour will automatically appear on the plot. If you add a new type of data (such as &amp;ldquo;power&amp;rdquo; for a power meter), a third facet will appear. Try it! Just modify the Python script to send data from a new location and re-run the python script, the &lt;code&gt;data &amp;lt;- getRaw()&lt;/code&gt; line, and the latest qplot instruction.&lt;/p&gt;

&lt;p&gt;If the date scale looks wrong, with one tick per point on the x axis, try adding &lt;code&gt;scale_x_datetime&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qplot(date, value, data = data, colour = origin, geom = &amp;quot;line&amp;quot;) + scale_x_datetime() + facet_grid(variable ~ ., scales = &amp;quot;free_y&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;other-forms-of-plots:94191fbd145b96fca71414b523ebad09&#34;&gt;Other forms of plots.&lt;/h2&gt;

&lt;p&gt;How about box plots to observe variations in temperature and humidity? Easy: just change x axis to &amp;ldquo;origin&amp;rdquo;, ditch the colours, and change geometry to &amp;ldquo;boxplot&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qplot(origin, value, data = data, geom = &amp;quot;boxplot&amp;quot;) + facet_grid(variable ~ ., scales = &amp;quot;free_y&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/25_boxplots.png&#34; alt=&#34;Box plots are even easier than time series&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Have a look at the qplot official documents for more inspiration on plot types: &lt;a href=&#34;http://docs.ggplot2.org/current&#34;&gt;http://docs.ggplot2.org/current&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;filtering-by-date:94191fbd145b96fca71414b523ebad09&#34;&gt;Filtering by date&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll cover a final R topic before moving on: filtering data frames, and in particular filtering by date. To filter a data frame, we extract a &lt;em&gt;subset&lt;/em&gt; of the data that fulfills a condition. For example, if we want to retrieve all the lines of &lt;code&gt;data&lt;/code&gt; that contain a &lt;code&gt;temperature&lt;/code&gt; measurement, pick the subset:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data.filt &amp;lt;- subset(data, variable == &#39;temperature&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s keep all the data from the second half of our measurement period. Pick a timestamp from the middle of the data frame and create a &lt;code&gt;POSIXct object from it&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ts &amp;lt;- data$timestamp[nrow(data) / 2]
mindate &amp;lt;- as.POSIXct(ts, tz = &amp;quot;GMT&amp;quot;, origin = &amp;quot;1970-01-01&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;POSIXct objects allow comparisons (&lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;), so we can use &lt;code&gt;mindate&lt;/code&gt; to filter the data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data.filt &amp;lt;- subset(data, date &amp;gt; mindate)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wrapping-them-in-functions-for-shiny:94191fbd145b96fca71414b523ebad09&#34;&gt;Wrapping them in functions for Shiny&lt;/h2&gt;

&lt;p&gt;For easy access later in Shiny, we&amp;rsquo;ll just shove the two &lt;code&gt;qplot&lt;/code&gt; calls in a function. Our &lt;code&gt;helpers.R&lt;/code&gt; file now looks like this, with the library import statement added:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;library(ggplot2)

getRaw &amp;lt;- function () {
  data &amp;lt;- read.csv(
    url(&amp;quot;https://script.google.com/macros/s/AKfycbxOw-Tl_r0jDV4wcnixdYdUjcNipSzgufiezRKr28Q5OAN50cIP/exec?sheet=Raw&amp;quot;),
    strip.white = TRUE
  )

  data$date = as.POSIXct(data$timestamp, tz=&amp;quot;GMT&amp;quot;, origin=&amp;quot;1970-01-01&amp;quot;)
  data
}

timeseriesPlot &amp;lt;- function(data) {
  qplot(date, value, data = data, colour = origin, geom = &amp;quot;line&amp;quot;) + scale_x_datetime() + facet_grid(variable ~ ., scales = &amp;quot;free_y&amp;quot;)
}

boxPlot &amp;lt;- function(data) {
  qplot(origin, value, data = data, geom = &amp;quot;boxplot&amp;quot;) + facet_grid(variable ~ ., scales = &amp;quot;free_y&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Build an internet-of-things dashboard with Google Sheets and RStudio Shiny: Tutorial part 1/3.</title>
      <link>http://douglas-watson.github.io/post/gdocs_1_gdocs/</link>
      <pubDate>Sun, 27 Dec 2015 13:21:30 +0100</pubDate>
      
      <guid>http://douglas-watson.github.io/post/gdocs_1_gdocs/</guid>
      <description>

&lt;p&gt;In part one of this tutorial, you will learn how to script a Google Sheet to store data from your hardware using an HTTP POST request and to retrieve the sheet&amp;rsquo;s data using an HTTP GET requests. On the way, you will also experiment with some of the spreadsheet&amp;rsquo;s built-in analytics tools: filters, pivot tables, and charts.&lt;/p&gt;

&lt;p&gt;Skip to &lt;a href=&#34;http://douglas-watson.github.io/post/gdocs_2_r/&#34;&gt;part 2&lt;/a&gt; to learn how to fetch and manipulate this data in R, or &lt;a href=&#34;http://douglas-watson.github.io/post/gdocs_3_shiny/&#34;&gt;part 3&lt;/a&gt; to learn how to use Shiny.&lt;/p&gt;

&lt;p&gt;The finished code files are available on Github: &lt;a href=&#34;https://github.com/douglas-watson/shiny-gdocs&#34;&gt;https://github.com/douglas-watson/shiny-gdocs&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;prelude-data-storage-format:ad12335119693a6c644dff7295437abd&#34;&gt;Prelude: data storage format&lt;/h1&gt;

&lt;p&gt;For each data point logged from the sensors,  we will store: a timestamp, the device ID, a variable name (&amp;ldquo;temperature&amp;rdquo;, or &amp;ldquo;humidity&amp;rdquo;), and finally the value of that reading. This means each reading of the sensor produces two lines: one for temperature and one for humidity. This format is what R users call &amp;ldquo;long format&amp;rdquo;. In the example below, we monitor two rooms every three seconds:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;timestamp&lt;/th&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;variable&lt;/th&gt;
&lt;th&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1448227096&lt;/td&gt;
&lt;td&gt;kitchen&lt;/td&gt;
&lt;td&gt;temperature&lt;/td&gt;
&lt;td&gt;22.3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1448227096&lt;/td&gt;
&lt;td&gt;kitchen&lt;/td&gt;
&lt;td&gt;humidity&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1448227096&lt;/td&gt;
&lt;td&gt;bedroom&lt;/td&gt;
&lt;td&gt;temperature&lt;/td&gt;
&lt;td&gt;24.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1448227096&lt;/td&gt;
&lt;td&gt;bedroom&lt;/td&gt;
&lt;td&gt;humidity&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1448227099&lt;/td&gt;
&lt;td&gt;kitchen&lt;/td&gt;
&lt;td&gt;temperature&lt;/td&gt;
&lt;td&gt;22.4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1448227099&lt;/td&gt;
&lt;td&gt;kitchen&lt;/td&gt;
&lt;td&gt;humidity&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1448227099&lt;/td&gt;
&lt;td&gt;bedroom&lt;/td&gt;
&lt;td&gt;temperature&lt;/td&gt;
&lt;td&gt;23.9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1448227099&lt;/td&gt;
&lt;td&gt;bedroom&lt;/td&gt;
&lt;td&gt;humidity&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Contrast this to the &amp;ldquo;wide&amp;rdquo; format, where each variable has its own column:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;timestamp&lt;/th&gt;
&lt;th&gt;kitchen temperature&lt;/th&gt;
&lt;th&gt;kitchen humidity&lt;/th&gt;
&lt;th&gt;bedroom temperature&lt;/th&gt;
&lt;th&gt;bedroom humidity&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1448227096&lt;/td&gt;
&lt;td&gt;22.3&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;24.0&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1448227099&lt;/td&gt;
&lt;td&gt;22.4&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;23.9&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The wide format is more obvious to work with and more compact, but isn&amp;rsquo;t easily extensible: if we add a new sensor to our system, we need to add a column to the file. With the long format, we just keep appending new lines. The long format also suits R analysis well, and can be transformed into the wide format using a pivot table in a spreadsheet.&lt;/p&gt;

&lt;p&gt;Finally, we&amp;rsquo;ll exchange data in Comma-Separated Values (CSV) format, because it is easy to generate from an embedded device, easy to store as a text file, and easy to read in any text editor or spreadsheet application.&lt;/p&gt;

&lt;h1 id=&#34;1-preparing-a-spreadsheet-to-receive-data:ad12335119693a6c644dff7295437abd&#34;&gt;1. Preparing a spreadsheet to receive data&lt;/h1&gt;

&lt;p&gt;If you don&amp;rsquo;t have a google drive account, create one. Then:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a new spreadsheet in Google drive&lt;/li&gt;
&lt;li&gt;Rename the first sheet (a sheet is a tab in the document) to &amp;ldquo;Raw&amp;rdquo;. This is where the data will be logged to.&lt;/li&gt;
&lt;li&gt;Create the header row. Each line of data, will have: a unix timestamp (number of seconds since 1 January 1970), a separate column as a human-readable date, then the columns &amp;ldquo;id&amp;rdquo;, &amp;ldquo;variable&amp;rdquo;, and &amp;ldquo;value&amp;rdquo; explained above. You can freeze the row, to keep it visible when scrolling, with &amp;ldquo;View&amp;rdquo; &amp;gt; &amp;ldquo;Freeze&amp;rdquo; &amp;gt; &amp;ldquo;1 Row&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Open the script editor, in the &amp;ldquo;Tools&amp;rdquo; &amp;gt; &amp;ldquo;Script editor&amp;hellip;&amp;rdquo; menu.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You are now ready to code!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/0_gdoc_init.png&#34; alt=&#34;Create a header row, then open the script editor.&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-1-appending-a-line-from-google-script:ad12335119693a6c644dff7295437abd&#34;&gt;1.1 Appending a line from google script&lt;/h2&gt;

&lt;p&gt;You should now be looking at the script editor. This tool allows you to write custom spreadsheet functions (which are called like &lt;code&gt;=SUM(A1:A5)&lt;/code&gt;), and to write simple web applications. Our first step will be to write a function that appends CSV data to the spreadsheet. Copy this code into the script editor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function appendLines(worksheet, csvData) {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheet = ss.getSheetByName(worksheet);

  var rows = Utilities.parseCsv(csvData);

  for ( var i = 0; i &amp;lt; rows.length; i++ ) {
    sheet.appendRow(rows[i]);
  }
}

function test() {
  Logger.log(&amp;quot;Appending fake data&amp;quot;);
  appendLines(&amp;quot;Raw&amp;quot;, &amp;quot;12345, Monday, kitchen, temperature, 30\n12346, Tuesday, living room, humidity, 50&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our appendLine function does this:
- Open the current spreadsheet (full document);
- select a sheet within the document, as identified by the first argument (we currently only have one, named Raw);
- parse the CSV data given as the second argument;
- for each line in the CSV data, append the line to the sheet.&lt;/p&gt;

&lt;p&gt;We additionally wrote a small &lt;code&gt;test&lt;/code&gt; function which calls appendLines, to make sure everything works. To run it, select the &lt;code&gt;test&lt;/code&gt; function in the toolbar and click the run button. If you are asked to authorize the script, do so. This should have appended two lines to the spreadsheet. You can also view the log output with &amp;ldquo;View&amp;rdquo; &amp;gt; &amp;ldquo;Logs&amp;rdquo; in the script editor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/1_code_editor.png&#34; alt=&#34;To test your code from the script editor, click the run button.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Two lines of data should be added to the spreadsheet:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/2_appended_data.png&#34; alt=&#34;Two lines of data should be added to the spreadsheet&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Our code has a critical flaw, however: later, when we&amp;rsquo;ll call it as a web service, the script will have no active spreadsheet associated. We need to change the code to fetch the spreadsheet from its unique ID. Find the document ID in the URL of spreadsheet:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/3_id.png&#34; alt=&#34;Find the document ID in its URL&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then modify &lt;code&gt;appendLines&lt;/code&gt; to fetch the document by ID:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function appendLines(worksheet, csvData) {
  var ss = SpreadsheetApp.openById(&amp;quot;13_BUd7WJlA8Z9B5Vc-5tyf3vyRUYmIx67sDz7ZmyPG4&amp;quot;);
  var sheet = ss.getSheetByName(worksheet);

  var rows = Utilities.parseCsv(csvData);

  for ( var i = 0; i &amp;lt; rows.length; i++ ) {
    sheet.appendRow(rows[i]);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the test function again, it should append another two lines to the &amp;ldquo;Raw&amp;rdquo; tab.&lt;/p&gt;

&lt;h2 id=&#34;receiving-post-data:ad12335119693a6c644dff7295437abd&#34;&gt;Receiving POST data&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s now expose this function to the web. Google scripts accept two special functions that handle GET and POST HTTP requests: &lt;code&gt;doGet&lt;/code&gt; and &lt;code&gt;doPost&lt;/code&gt;, respectively. These functions take a single argument of type &lt;code&gt;Event&lt;/code&gt; (which we will get to), and must return a special object from the &lt;code&gt;ContentService&lt;/code&gt; or &lt;code&gt;HtmlService&lt;/code&gt;. To explore the API, we&amp;rsquo;ll first make a function that responds to POST requests by returning the contents of the Event object in JSON format. Add the following code to the script editor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function doPost(e) {
  var params = JSON.stringify(e);
  return ContentService.createTextOutput(params);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now publish it with &amp;ldquo;Publish&amp;rdquo; &amp;gt; &amp;ldquo;Deploy as web app&amp;hellip;&amp;rdquo;. Give the version a brief description, ask to execute it as yourself, and allow anonymous access, so that you can post to the spreadsheet without authentication, then deploy:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/4_publish.png&#34; alt=&#34;Publishing our first web app!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Copy the URL:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/5_published.png&#34; alt=&#34;Publishing our first web app!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s one last thing you need to do before sending HTTP requests to this new web server. Share the spreadsheet publicly. Return to the spreadsheet tab, and open &amp;ldquo;File&amp;rdquo; &amp;gt; &amp;ldquo;Share&amp;hellip;&amp;rdquo;. Click &amp;ldquo;Get shareable link&amp;rdquo;, and allow anyone with the link to edit:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/6_share.png&#34; alt=&#34;Share the spreadsheet publicly to avoid authentication errors&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, fire up your favourite HTTP client (the Postman Chrome extension is a great graphical tool). I&amp;rsquo;ll be using CURL, from the console. Send a first POST request to the URL you copied above. If using CURL make sure to add the &lt;code&gt;-L&lt;/code&gt; option to follow redirects, and the &lt;code&gt;--data&lt;/code&gt; option to make a POST request. For my URL, I get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl --data &amp;quot;hello, world&amp;quot; &amp;quot;https://script.google.com/macros/s/AKfycbxOw-Tl_r0jDV4wcnixdYdUjcNipSzgufiezRKr28Q5OAN50cIP/exec&amp;quot;

{&amp;quot;parameter&amp;quot;:{&amp;quot;hello, world&amp;quot;:&amp;quot;&amp;quot;},&amp;quot;contextPath&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;contentLength&amp;quot;:12,&amp;quot;queryString&amp;quot;:null,&amp;quot;parameters&amp;quot;:{&amp;quot;hello, world&amp;quot;:[&amp;quot;&amp;quot;]},&amp;quot;postData&amp;quot;:{&amp;quot;length&amp;quot;:12,&amp;quot;type&amp;quot;:&amp;quot;application/x-www-form-urlencoded&amp;quot;,&amp;quot;contents&amp;quot;:&amp;quot;hello, world&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;postData&amp;quot;}}%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My POST request received some JSON as response. This JSON shows us the structure of the &lt;code&gt;e&lt;/code&gt; argument passed to &lt;code&gt;doPost&lt;/code&gt;. You&amp;rsquo;ll recognize the &amp;ldquo;hello, world&amp;rdquo; POST data stored in &lt;code&gt;e[&amp;quot;postData&amp;quot;][&amp;quot;contents&amp;quot;]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can use the URL to pass arguments to &lt;code&gt;doPost&lt;/code&gt;. Repeat the same request, but append &lt;code&gt;?sheet=Raw&lt;/code&gt; to the URL (make sure the URL is quoted):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L --data &amp;quot;hello, world&amp;quot; &amp;quot;https://script.google.com/macros/s/AKfycbxOw-Tl_r0jDV4wcnixdYdUjcNipSzgufiezRKr28Q5OAN50cIP/exec?sheet=Raw&amp;quot;

{&amp;quot;parameter&amp;quot;:{&amp;quot;sheet&amp;quot;:&amp;quot;Raw&amp;quot;,&amp;quot;hello, world&amp;quot;:&amp;quot;&amp;quot;},&amp;quot;contextPath&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;contentLength&amp;quot;:12,&amp;quot;queryString&amp;quot;:&amp;quot;sheet=Raw&amp;quot;,&amp;quot;parameters&amp;quot;:{&amp;quot;sheet&amp;quot;:[&amp;quot;Raw&amp;quot;],&amp;quot;hello, world&amp;quot;:[&amp;quot;&amp;quot;]},&amp;quot;postData&amp;quot;:{&amp;quot;length&amp;quot;:12,&amp;quot;type&amp;quot;:&amp;quot;application/x-www-form-urlencoded&amp;quot;,&amp;quot;contents&amp;quot;:&amp;quot;hello, world&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;postData&amp;quot;}}%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The URL parameter appeared as &lt;code&gt;e[&amp;quot;parameter&amp;quot;][&amp;quot;sheet&amp;quot;]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that we understand the structure of the event object, we can modify &lt;code&gt;doPost&lt;/code&gt; to:
- Look for a &amp;ldquo;sheet&amp;rdquo; argument in the URL
- Extract CSV data from the POST request payload
- Append all lines in the CSV data to the designated sheet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function doPost(e) {
  var contents = e.postData.contents;
  var sheetName = e.parameter[&#39;sheet&#39;];

  // Append to spreadsheet
  appendLines(sheetName, contents);

  var params = JSON.stringify(e);
  return ContentService.createTextOutput(params);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Publish a new version of the app (&amp;ldquo;Publish&amp;rdquo; &amp;gt; &amp;ldquo;Deploy as web app&amp;hellip;&amp;rdquo;, set &amp;ldquo;Project Version&amp;rdquo; to &amp;ldquo;new&amp;rdquo;, describe it, and click &amp;ldquo;update&amp;rdquo;). You can now append lines to the spreadsheet through an HTTP Post request! Rerun the last curl command, and observe the newest line added to your spreadsheet:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/7_post_append.png&#34; alt=&#34;You recorded data from an HTTP request!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Clear the spreadsheet now: delete all rows except for the header.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;More on &lt;code&gt;doGet&lt;/code&gt; and &lt;code&gt;doPost&lt;/code&gt;: &lt;a href=&#34;https://developers.google.com/apps-script/guides/web&#34;&gt;https://developers.google.com/apps-script/guides/web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;More on Event objects: &lt;a href=&#34;https://developers.google.com/apps-script/guides/triggers/events&#34;&gt;https://developers.google.com/apps-script/guides/triggers/events&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;uploading-data-from-python:ad12335119693a6c644dff7295437abd&#34;&gt;Uploading data from python&lt;/h1&gt;

&lt;p&gt;In practice, you&amp;rsquo;ll be uploading data using POST requests from the language of choice of your IOT platform. To generate data for this tutorial, I used a python script which creates some random humidity and temperature data for two rooms, in one hour intervals, and uploads them to the spreadsheet. Feel free to skip this section; if you wish to follow the last part of the tutorial, you may also generate data by hand or with other tools.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time
import datetime
import random
import requests

URL = &#39;https://script.google.com/macros/s/AKfycbxOw-Tl_r0jDV4wcnixdYdUjcNipSzgufiezRKr28Q5OAN50cIP/exec&#39;

def gdoc_post(data):
    csv = &amp;quot;\n&amp;quot;.join(
        &amp;quot;,&amp;quot;.join(str(it) for it in line) for line in data
    )

    requests.post(URL + &amp;quot;?sheet=Raw&amp;quot;, csv)

def make_temperature():
    return random.randrange(230, 250) / 10.

def make_humidity():
    return random.randrange(400, 500) / 10.

if __name__ == &#39;__main__&#39;:
    now = time.time()
    for i in xrange(60):
        timestamp = now + 60 * 60 * i
        date = datetime.datetime.fromtimestamp(timestamp)

        data = [
            [timestamp, date, &#39;kitchen&#39;, &#39;temperature&#39;, make_temperature()],
            [timestamp, date, &#39;kitchen&#39;, &#39;humidity&#39;, make_humidity()],
            [timestamp, date, &#39;bedroom&#39;, &#39;temperature&#39;, make_temperature()],
            [timestamp, date, &#39;bedroom&#39;, &#39;humidity&#39;, make_humidity()],
        ]

        gdoc_post(data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run this example, you&amp;rsquo;ll need the Python language and the &lt;code&gt;requests&lt;/code&gt; library. Python should be installed by default on most Linux distributions and OS X. On Windows, I recommend installing the Anaconda distribution, or Python (x, y). Install &lt;code&gt;requests&lt;/code&gt; with &lt;code&gt;easy_install&lt;/code&gt; (or &lt;code&gt;pip&lt;/code&gt; if you have it):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;easy_install requests
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, replace the URL in the code above with your web app URL, save it as &lt;code&gt;uploads.py&lt;/code&gt;, and run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python uploads.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Return to the spreadsheet. You should see the lines appearing as the script sends them:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/8_python_append.png&#34; alt=&#34;Fake data uploaded from a Python script&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;analytics-within-the-spreadsheet:ad12335119693a6c644dff7295437abd&#34;&gt;Analytics within the spreadsheet&lt;/h1&gt;

&lt;p&gt;Before we move on to exporting the data, let&amp;rsquo;s play with the built-in analytical capabilities of the spreadsheet: we can apply simple filters to the data, extract information with pivot tables, and display it with various charts. Being a web-based application, Sheets even allows those charts to be embedded on web pages directly.&lt;/p&gt;

&lt;h2 id=&#34;filters:ad12335119693a6c644dff7295437abd&#34;&gt;Filters&lt;/h2&gt;

&lt;p&gt;Filters allow you to show or hide rows of data based on one or several criteria. They are ridiculously simple to use: select the columns you want to filter, then click the funnel symbol in the toolbar. Little arrow icons appear next to each column header. Clicking these pops down a menu from which you can choose filtering criteria. Try restricting the data to only today&amp;rsquo;s data, or only temperature measurements.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/9_filters.png&#34; alt=&#34;Filters hide rows based on a search criteria. Here, we filter based on date, to show only today&#39;s data.&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;pivot-tables:ad12335119693a6c644dff7295437abd&#34;&gt;Pivot tables&lt;/h2&gt;

&lt;p&gt;Pivot tables transform long-format data into wide-format data. Select columns A:G, by clicking the A letter above the header row, and dragging to the G letter. Go to the &amp;ldquo;Data&amp;rdquo; &amp;gt; &amp;ldquo;Pivot table&amp;rdquo; menu option. This opens a new blank sheet, with a right-hand-side menu to configure the pivot table. Select the &amp;ldquo;date&amp;rdquo; column for rows, &amp;ldquo;origin&amp;rdquo; for the columns, and &amp;ldquo;value&amp;rdquo; for the values &amp;ndash; summarize by AVERAGE for the totals to make sense. Finally, filter by &amp;ldquo;variable&amp;rdquo;, showing only &amp;ldquo;temperature&amp;rdquo;. Your configuration and pivot table should look similar to the screenshot below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/10_pivot_table.png&#34; alt=&#34;Pivot tables&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You now have a table that extracts only temperature data and presents them by room. If you kept the &amp;ldquo;show totals&amp;rdquo; option checked, you&amp;rsquo;ll also have an average temperature at each point in time, and an average per room. Note that it updates live, as soon as new data arrives!&lt;/p&gt;

&lt;p&gt;As an exercise, try making a pivot table that displays, for each room, the average, standard deviation, and measurement count for both temperature and humidity.&lt;/p&gt;

&lt;h2 id=&#34;graphs:ad12335119693a6c644dff7295437abd&#34;&gt;Graphs&lt;/h2&gt;

&lt;p&gt;We can make graphs from a pivot table in the usual &amp;ldquo;spreadsheet&amp;rdquo; way: select the columns of interest, and click the chart icon on the toolbar. Again, these charts are updated live, as new data is posted to the sheet.&lt;/p&gt;

&lt;p&gt;The screenshot below shows a &lt;em&gt;time line chart&lt;/em&gt;, moved to its own sheet. This chart can interactively zoom onto date ranges, and is thus ideal to represent time series data from a sensor. You could even embed the chart directly on a web page to make a monitoring dashboard (which could be hosted on google sites, if you are really lazy), using the &amp;ldquo;Publish chart&amp;rdquo; option.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/11_charts.png&#34; alt=&#34;Graphs&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;get-data-in-csv-format:ad12335119693a6c644dff7295437abd&#34;&gt;GET data in CSV format&lt;/h1&gt;

&lt;p&gt;The spreadsheet is a powerful analytics tool on its own, but our end goal in this tutorial is to retrieve the sensor data from other tools. We&amp;rsquo;ll do this by letting GET requests download a sheet in CSV format. To enable this, add a &lt;code&gt;doGet&lt;/code&gt; function in the Script Editor (make sure to replace the sheet ID by your own).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function doGet(e) {
  var sheetName = e.parameter[&#39;sheet&#39;];

  var ss = SpreadsheetApp.openById(&#39;13_BUd7WJlA8Z9B5Vc-5tyf3vyRUYmIx67sDz7ZmyPG4&#39;);
  var sheet = ss.getSheetByName(sheetName);
  var data = sheet.getDataRange().getValues();


  // Loop through the data in the range and build a string with the CSV data
  // taken from https://developers.google.com/apps-script/articles/docslist_tutorial#section2
  var csvFile = undefined
  if (data.length &amp;gt; 1) {
    var csv = &amp;quot;&amp;quot;;
    for (var row = 0; row &amp;lt; data.length; row++) {
      for (var col = 0; col &amp;lt; data[row].length; col++) {
         if (data[row][col].toString().indexOf(&amp;quot;,&amp;quot;) != -1) {
           data[row][col] = &amp;quot;\&amp;quot;&amp;quot; + data[row][col] + &amp;quot;\&amp;quot;&amp;quot;;
         }
      }

      // Join each row&#39;s columns
      // Add a carriage return to end of each row, except for the last one
      if (row &amp;lt; data.length-1) {
        csv += data[row].join(&amp;quot;,&amp;quot;) + &amp;quot;\r\n&amp;quot;;
      }
      else {
        csv += data[row];
      }
    }
    csvFile = csv;
  }

  return ContentService.createTextOutput(csvFile);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function is similar to doPost, in reverse: it opens the specified sheet, reads all data in the sheet, then encodes it in CSV format, and finally returns the CSV data. The scripting API doesn&amp;rsquo;t include a CSV encoding function, so instead we re-used a procedure shown in the official documentation.&lt;/p&gt;

&lt;p&gt;Deploy this new version of the web app. You can now download the data in CSV format! With curl, make sure to add the &lt;code&gt;-L&lt;/code&gt; option again, append &lt;code&gt;?sheet=Raw&lt;/code&gt; to the web app URL, and quote the URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L &#39;https://script.google.com/macros/s/AKfycbxOw-Tl_r0jDV4wcnixdYdUjcNipSzgufiezRKr28Q5OAN50cIP/exec?sheet=Raw&#39;

timestamp,date,origin,variable,value
1448315085.07,Mon Nov 23 2015 22:44:45 GMT+0100 (CET),kitchen,temperature,24.4
1448315085.07,Mon Nov 23 2015 22:44:45 GMT+0100 (CET),kitchen,humidity,44.9
1448315085.07,Mon Nov 23 2015 22:44:45 GMT+0100 (CET),bedroom,temperature,24.8
1448315085.07,Mon Nov 23 2015 22:44:45 GMT+0100 (CET),bedroom,humidity,46.1
1448318685.07,Mon Nov 23 2015 23:44:45 GMT+0100 (CET),kitchen,temperature,23
1448318685.07,Mon Nov 23 2015 23:44:45 GMT+0100 (CET),kitchen,humidity,41.1
1448318685.07,Mon Nov 23 2015 23:44:45 GMT+0100 (CET),bedroom,temperature,23.6
1448318685.07,Mon Nov 23 2015 23:44:45 GMT+0100 (CET),bedroom,humidity,45.7
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have a single sheet to export, you could also experiment with the &amp;ldquo;Publish to the web&amp;rdquo; function of Spreadsheets. In my own application, I needed access to several sheets, so I created my own export function.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build an internet-of-things dashboard with Google Sheets and RStudio Shiny: Tutorial Series.</title>
      <link>http://douglas-watson.github.io/post/gdocs_0_intro/</link>
      <pubDate>Sun, 27 Dec 2015 13:21:24 +0100</pubDate>
      
      <guid>http://douglas-watson.github.io/post/gdocs_0_intro/</guid>
      <description>

&lt;p&gt;Logging data to a central server and displaying it online is a common task in Internet of Things applications. This usually requires deploying and maintaining your own servers, with a database for storage and a web server for display. System administration tasks are no fun to me, so instead I found a way to use Google Sheets as a server, and ShinyApps.io as a visualization platform. Uploading data to Google docs is relatively simple and well documented, but connecting Shiny to Google Docs was a little more tricky; this motivated me to write this tutorial to show others how to set up a similar system.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;http://douglas-watson.github.io/post/gdocs_1_gdocs/&#34;&gt;part one&lt;/a&gt;, I&amp;rsquo;ll explain how to set up a Google spreadsheet as data storage and use it as an elementary dashboard. In &lt;a href=&#34;http://douglas-watson.github.io/post/gdocs_2_r/&#34;&gt;part two&lt;/a&gt;, I&amp;rsquo;ll teach you how to retrieve that data in R, and plot it with the ggplot2 library. In &lt;a href=&#34;http://douglas-watson.github.io/post/gdocs_3_shiny/&#34;&gt;part three&lt;/a&gt;, I&amp;rsquo;ll walk you through making a simple interactive visualization in Shiny and publishing it online to ShinyApps.io.&lt;/p&gt;

&lt;p&gt;During the tutorial, we&amp;rsquo;ll pretend to have a network of several temperature and humidity sensors. Each sensor is named after its location name (such as &amp;ldquo;bedroom&amp;rdquo; or &amp;ldquo;living room&amp;rdquo;), and records the temperature every hour. I assume you know how to program your IOT hardware to make HTTP requests; for the sake of the tutorial I provide a Python script to upload fake temperature and humidity values.&lt;/p&gt;

&lt;h2 id=&#34;why-use-google-sheets:1d31138e44f763ff5e61f4534683debe&#34;&gt;Why use Google Sheets?&lt;/h2&gt;

&lt;p&gt;Google spreadsheets can serve as a simple server to store and retrieve data, while writing surprisingly little code. We avoid maintaining our own servers, and we additionally benefit from easy access to the raw data. On top of that, the spreadsheets on their own are powerful analysis tools, with statistics, pivot tables, filters, and interactive charts which can be embedded on external websites.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/11_charts.png&#34; alt=&#34;Google Sheets on their own are a powerful analytics tool for distributed data&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;why-use-r-and-shiny:1d31138e44f763ff5e61f4534683debe&#34;&gt;Why use R and Shiny?&lt;/h2&gt;

&lt;p&gt;R is a powerful language specifically designed for data analysis. Combined with the ggplot2 graphing library, it provides an ideal package to explore and visualize large amounts data. Once you have figured out what you want to show, Shiny allows you to take your visualizations, make them interactive, and publish them on the web. RStudio, the makers of Shiny, even provide free hosting for visualizations, which makes the service quite convenient to experiment with.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://douglas-watson.github.io/images/gdocs/32_fullui.png&#34; alt=&#34;The final product of our tutorial: a live interactive web-based dashboard&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://douglas-watson.github.io/about/</link>
      <pubDate>Sun, 27 Dec 2015 13:01:07 +0100</pubDate>
      
      <guid>http://douglas-watson.github.io/about/</guid>
      <description>&lt;p&gt;I look after software in a hardware startup. I frequently code in Python and Go, and sometimes in R, Javascript, and MATLAB.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve often found other developers blogs to be useful resources, so I&amp;rsquo;m setting up my own to share some tips and tricks.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>